\section{Blockchain interface}
\label{sec:blockchain-interface}

\newcommand{\DIEnv}{\type{DIEnv}}
\newcommand{\DIState}{\type{DIState}}

\newcommand{\UPIEnv}{\type{UPIEnv}}
\newcommand{\UPIState}{\type{UPIState}}

\subsection{Delegation interface}
\label{sec:delegation-interface}

\begin{figure}[htb]
  \emph{Delegation interface environments}
  \begin{equation*}
    \DIEnv =
    \left(
      \begin{array}{r@{~\in~}lr}
        \mathcal{K} & \powerset{\VKeyGen} & \text{allowed delegators}\\
        \var{e} & \Epoch & \text{epoch}\\
        \var{s} & \Slot & \text{slot}\\
        \var{d} & \SlotCount & \text{certificate liveness parameter}
      \end{array}
    \right)
  \end{equation*}

  \emph{Delegation interface states}
  \begin{equation*}
    \DIState
    = \left(
      \begin{array}{r@{~\in~}lr}
        \var{dms} & \VKeyGen \mapsto \VKey & \text{delegation map}\\
        \var{dws} & \VKeyGen \mapsto \Slot & \text{when last delegation occurred}\\
        \var{sds} & \seqof{(\Slot \times (\VKeyGen \times \VKey))} & \text{scheduled delegations}\\
        \var{eks} & \powerset{(\Epoch \times \VKeyGen)} & \text{key-epoch delegations}
      \end{array}
    \right)
  \end{equation*}

  \emph{Delegation transitions}
  \begin{equation*}
    \_ \vdash \_ \trans{deleg}{\_} \_ \in
    \powerset (\DIEnv \times \DIState \times \seqof{\DCert} \times \DIState)
  \end{equation*}
  \caption{Delegation interface transition-system types}
  \label{fig:ts-types:delegation-interface}
\end{figure}

\subsubsection{Delegation interface rules}
\label{sec:delegation-interface-rules}

\begin{figure}[htb]
  \begin{equation}
    \label{eq:rule:delegation-interface}
    \inference
    {
      {\begin{array}{l}
         \mathcal{K} \\
         e\\
         s\\
         d
       \end{array}}
      \vdash
      {
        \left(
          \begin{array}{l}
            \var{sds}\\
            \var{eks}
          \end{array}
        \right)
      }
      \trans{sdelegs}{\Gamma}
      {
        \left(
          \begin{array}{l}
            \var{sds'}\\
            \var{eks'}
          \end{array}
        \right)
      }
      &
      {
        \left(
          \begin{array}{l}
            \var{dms}\\
            \var{dws}
          \end{array}
        \right)
      }
      \trans{adelegs}{[.., s] \restrictdom \var{sds'}}
      {
        \left(
          \begin{array}{l}
            \var{dms'}\\
            \var{dws'}
          \end{array}
        \right)
      }
    }
    {
      {\begin{array}{l}
         \mathcal{K} \\
         e\\
         s\\
         d
      \end{array}}
      \vdash
      {
        \left(
          \begin{array}{l}
            \var{dms}\\
            \var{dws}\\
            \var{sds}\\
            \var{eks}
          \end{array}
        \right)
      }
      \trans{deleg}{\Gamma}
      {
        \left(
          \begin{array}{l}
            \var{dms'}\\
            \var{dws'}\\
            \var{[s-d,~ s+d]} \restrictdom \var{sds'}\\
            \var{[e, ..]} \restrictdom \var{eks'}
          \end{array}
        \right)
      }
    }
  \end{equation}
  \caption{Delegation interface rules}
  \label{fig:rules:delegation-interface}
\end{figure}

\subsubsection{Delegation interface functions}
\label{sec:delegation-interface-functions}

\begin{figure}[htb]
  \begin{align*}
    & \fun{delegates} \in \DIState \to (\VKeyGen \times \VKey) \to \Bool & \text{delegation relationship}\\
    & \fun{delegates}~s~(\var{vk_s}, \var{vk_d}) = \var{vk_s} \mapsto \var{vk_d} \in (\var{dms}~s)\\
    \nextdef
    & \fun{initialDS} \in \VKeyGen \to \DIState & \text{initial delegation state}\\
    & \fun{initialDS}~\var{ks} =
      \left(
      \begin{array}{l}
        \var{ks} \mapsto \var{ks}\\
        \emptyset\\
        \epsilon\\
        \emptyset\\
      \end{array}
      \right)
  \end{align*}
  \caption{Delegation interface functions}
\end{figure}

\clearpage

\subsection{Update-proposals interface}
\label{sec:update-proposals-interface}

Figure~\ref{fig:ts-types:upi} defines the types of the transition systems
related with the update-proposals interface. The acronyms in the transition
labels have the following meaning:
\begin{description}
\item[UPIREG] Update-proposal registration.
\item[UPIEND] Update-proposal vote.
\item[UPIEND] Update-proposal endorsement.
\item[UPIEC] Update-proposal epoch-change.
\end{description}

\begin{figure}[htb]
  \emph{Update-proposals interface environments}
  \begin{align*}
    & \UPIEnv
      = \left(
      \begin{array}{r@{~\in~}lr}
        \var{k} & \mathbb{N} & \text{chain stability parameter}\\
        \var{u} & \mathbb{N} & \text{update proposals time-to-live}\\
        \var{e_c} & \Epoch & \text{current epoch}\\
        \var{b_n} & \BkNr & \text{current block number}\\
        \var{dms} & \VKeyGen \mapsto \VKey & \text{delegation map}\\
      \end{array}\right)
  \end{align*}
  %
  \emph{Update-proposals interface states}
  \begin{align*}
    & \UPIState
      = \left(
      \begin{array}{r@{~\in~}lr}
        \var{e_p} & \Epoch & \text{previously seen epoch}\\
        (\var{pv}, \var{pps}) & \ProtVer \times \PPMMap
        & \text{current protocol information}\\
        (\var{pv_c}, \var{pps_c}) & \ProtVer \times \PPMMap
        & \text{candidate protocol information}\\
        \var{rups} & \Rups
        & \text{registered update proposals}\\
        \var{eps} & \powerset{(\Epoch \times \VKeyGen)}
        & \text{proposals per-epoch per-key}\\
        \var{cps} & \UPropId \mapsto \BkNr & \text{confirmed proposals}\\
        \var{vts} & \powerset{(\UPropId \times \VKeyGen)} & \text{proposals votes}\\
        \var{bvs} & \powerset{(\ProtVer \times \VKeyGen)}
                           & \text{endorsement-key pairs}\\
        \var{pws} & \UPropId \mapsto \BkNr & \text{proposal timestamps}
      \end{array}\right)
  \end{align*}
  %
  \emph{Update-proposals interface transitions}
  \begin{equation*}
    \begin{array}{r@{~\in~}l}
      \_ \vdash \_ \trans{upireg}{\_} \_ &
      \powerset (\UPIEnv \times \UPIState \times \UProp \times \UPIState)\\
      \_ \vdash \_ \trans{upivote}{\_} \_ &
      \powerset (\UPIEnv \times \UPIState \times \Vote \times \UPIState)\\
      \_ \vdash \_ \trans{upiend}{\_} \_ &
      \powerset (\UPIEnv \times \UPIState
      \times (\ProtVer \times \VKey) \times \UPIState)\\
      \_ \vdash \_ \trans{upiec}{\_} \_ &
      \powerset (\UPIEnv \times \UPIState \times \Epoch \times \UPIState)
    \end{array}
  \end{equation*}
  \caption{Update-proposals interface transition-system types}
  \label{fig:ts-types:upi}
\end{figure}


\begin{figure}[htb]
  \begin{equation}
    \label{eq:rule:upi-reg-interface}
    \inference
    {
      {
        \begin{array}{l}
          \var{pv}\\
          \var{pps}\\
          \var{e_c}\\
          \var{dms}
        \end{array}
      }
      \vdash
      {
        \left(
          \begin{array}{l}
            \var{rups}\\
            \var{eps}
          \end{array}
        \right)
      }
      \trans{upreg}{\var{up}}
      {
        \left(
          \begin{array}{l}
            \var{rups'}\\
            \var{eps'}
          \end{array}
        \right)
      }
      &
      pws' = pws \unionoverride \{ \upId{up} \mapsto b_n\}
    }
    {
      {
        \begin{array}{l}
          k\\
          u\\
          e_c\\
          b_n\\
          \var{dms}
        \end{array}
      }
      \vdash
      {
        \left(
          \begin{array}{l}
            \var{e_p}\\
            (\var{pv}, \var{pps})\\
            (\var{pv_c}, \var{pps_c})\\
            \var{rups}\\
            \var{eps}\\
            \var{cps}\\
            \var{vts}\\
            \var{bvs}\\
            \var{pws}
          \end{array}
        \right)
      }
      \trans{upireg}{\var{up}}
      {
        \left(
          \begin{array}{l}
            \var{e_p}\\
            (\var{pv}, \var{pps})\\
            (\var{pv_c}, \var{pps_c})\\
            \var{rups'}\\
            \var{eps'}\\
            \var{cps}\\
            \var{vts}\\
            \var{bvs}\\
            \var{pws'}
          \end{array}
        \right)
      }
    }
  \end{equation}
  \caption{Update-proposals registration rules}
  \label{fig:rules:upi-reg-interface}
\end{figure}

\clearpage

\begin{figure}[htb]
  \begin{equation}
    \label{eq:rule:upi-vote}
    \inference
    {
      {
        \begin{array}{l}
          b_n\\
          \var{pps}\\
          \var{rups}\\
          \var{dms}
        \end{array}
      }
      \vdash
      {
        \left(
          \begin{array}{l}
            \var{cps}\\
            \var{vts}
          \end{array}
        \right)
      }
      \trans{upvote}{\var{v}}
      {
        \left(
          \begin{array}{l}
            \var{cps'}\\
            \var{vts'}
          \end{array}
        \right)
      }
    }
    {
      {
        \begin{array}{l}
          k\\
          u\\
          e_c\\
          b_n\\
          \var{dms}
        \end{array}
      }
      \vdash
      {
        \left(
          \begin{array}{l}
            \var{e_p}\\
            (\var{pv}, \var{pps})\\
            (\var{pv_c}, \var{pps_c})\\
            \var{rups}\\
            \var{eps}\\
            \var{cps}\\
            \var{vts}\\
            \var{bvs}\\
            \var{pws}
          \end{array}
        \right)
      }
      \trans{upivote}{\var{v}}
      {
        \left(
          \begin{array}{l}
            \var{e_p}\\
            (\var{pv}, \var{pps})\\
            (\var{pv_c}, \var{pps_c})\\
            \var{rups}\\
            \var{eps}\\
            \var{cps'}\\
            \var{vts'}\\
            \var{bvs}\\
            \var{pws}
          \end{array}
        \right)
      }
    }
  \end{equation}
  \caption{Voting on update-proposals rules}
  \label{fig:rules:upi-vote}
\end{figure}

\clearpage

The interface rule for protocol-block-version registration makes use of the
$\trans{upbvreg}{}$ transition, passing only the portion of the state relevant
to it. In addition, the unconfirmed proposals that are older than $u$ blocks
are removed from the parts of the state that hold:
\begin{itemize}
\item the registered proposals,
\item the votes associated with the proposals,
\item the set of endorsement-key pairs, and
\item the block number in which proposals where added.
\end{itemize}
The epoch-key pairs set ($\var{eps}$) that represents which stakeholder
proposed an update in which epoch, is cleaned up in the rules given in
\cref{fig:rules:upi-ec}, which deals with epoch change.

In Rule~\ref{eq:rule:upi-pend}, the set of proposal id's $\var{pid_{keep}}$
contains only those proposals that haven't expired yet or that are confirmed.
Once a proposal $\var{up}$ is confirmed, it is removed from the set of
confirmed proposals ($\var{cps}$) either when it is adopted or when a protocol
version higher than that of $\var{up}$ gets adopted (see
Rule~\ref{eq:rule:upi-ec}).
%
The set of endorsement-key pairs is cleaned here as well as in the epoch change
rule (Rule~\ref{eq:rule:upi-ec}). The reason for this is that this set grows at
each block, and it can get considerably large if no proposal gets adopted at
the end on an epoch.

\begin{figure}[htb]
  \begin{equation}
    \label{eq:rule:upi-pend}
    \inference
    {
      {
        \begin{array}{l}
          k\\
          b_n\\
          (\var{pv}, \var{pps})\\
          \var{dms}\\
          \var{cps}\\
          \var{rups}
        \end{array}
      }
      \vdash
      {
        \left(
          \begin{array}{l}
            (\var{pv_c}, \var{pps_c})\\
            \var{bvs}
          \end{array}
        \right)
      }
      \trans{upbvreg}{(\var{bv}, \var{vk})}
      {
        \left(
          \begin{array}{l}
            (\var{pv_c'}, \var{pps_c'})\\
            \var{bvs'}
          \end{array}
        \right)
      }\\
      {
        \begin{array}{r@{~=~}l}
          \var{pids_{keep}} & \dom~(pws \restrictrange [b_n - u, ..]) \cup \dom~\var{cps}\\
          \var{vs_{keep}} & \dom~(\range~\var{rups'})\\
          \var{rups'} & \var{pids_{keep}} \restrictdom \var{rups}
        \end{array}
      }
    }
    {
      {
        \begin{array}{l}
          k\\
          u\\
          e_c\\
          b_n\\
          \var{dms}
        \end{array}
      }
      \vdash
      {
        \left(
          \begin{array}{l}
            \var{e_p}\\
            (\var{pv}, \var{pps})\\
            (\var{pv_c}, \var{pps_c})\\
            \var{rups}\\
            \var{eps}\\
            \var{cps}\\
            \var{vts}\\
            \var{bvs}\\
            \var{pws}
          \end{array}
        \right)
      }
      \trans{upiend}{(\var{bv}, \var{vk})}
      {
        \left(
          \begin{array}{l}
            \var{e_p}\\
            (\var{pv}, \var{pps})\\
            (\var{pv_c'}, \var{pps_c'})\\
            \var{rups'}\\
            \var{eps}\\
            \var{cps}\\
            \var{pids_{keep}} \restrictdom \var{vts}\\
            \var{vs_{keep}}  \restrictdom \var{bvs}\\
            \var{pids_{keep}} \restrictdom \var{pws}
          \end{array}
        \right)
      }
    }
  \end{equation}
  \caption{Proposal endorsement rules}
  \label{fig:rules:upi-pend}
\end{figure}

\clearpage

Rule~\ref{eq:rule:upi-ec} models how the protocol version and its parameters
are changed depending on the epoch in the signal ($e_n$ in this case). A change
only occurs if the new epoch is greater than the previously seen epoch ($e_p$).
In such case, the current epoch is also updated accordingly. The candidate
versions and parameters map $(\var{pv_c}, \var{pps_c})$ remain constant in this
transition, even if they become adopted. Note that, in the final state, we use
union override to define the updated parameters
($\var{pps} \unionoverride \var{pps'}$). This is because candidate proposal
might only update some parameters of the protocol.

Rule~\ref{eq:rule:upi-ec} performs cleanup of several state variables. We keep
only the information of proposals whose proposed protocol-versions are greater
than the newly adopted protocol version ($\var{pv'}$). This means that active
proposals will be discarded even if the voting period is not over (it makes no
sense to vote on a proposal that proposes to upgrade to an older version of the
protocol). Furthermore, the set $\var{eps}$ is updated so that only keys that
proposed in epochs no earlier than $e_n$ are kept.

\begin{figure}[htb]
  \begin{equation}
    \label{eq:rule:pvbump-change-noop}
    \inference
    {
      e_n \leq e_p
    }
    {
      (\var{pv_c}, \var{pps_c})
      \vdash
      {
        \left(
          \begin{array}{l}
            \var{e_p}\\
            \var{(\var{pv}, \var{pps})}\\
          \end{array}
        \right)
      }
      \trans{pvbump}{\var{e_n}}
      {
        \left(
          \begin{array}{l}
            \var{e_p}\\
            \var{(\var{pv}, \var{pps})}\\
          \end{array}
        \right)
      }
    }
  \end{equation}
  \nextdef
  \begin{equation}
    \label{eq:rule:pvbump-change}
    \inference
    {
      e_p < e_n
    }
    {
      (\var{pv_c}, \var{pps_c})
      \vdash
      {
        \left(
          \begin{array}{l}
            \var{e_p}\\
            \var{(\var{pv}, \var{pps})}
          \end{array}
        \right)
      }
      \trans{pvbump}{\var{e_n}}
      {
        \left(
          \begin{array}{l}
            \var{e_n}\\
            \var{(\var{pv_c}, \var{pps_c})}
          \end{array}
        \right)
      }
    }
  \end{equation}
  \nextdef
  \begin{equation}
    \label{eq:rule:upi-ec}
    \inference
    {
      (\var{pv_c}, \var{pps_c})
      \vdash
      {
        \left(
          \begin{array}{l}
            \var{e_p}\\
            \var{(\var{pv}, \var{pps})}
          \end{array}
        \right)
      }
      \trans{pvbump}{\var{e_n}}
      {
        \left(
          \begin{array}{l}
            \var{e'}\\
            \var{(\var{pv'}, \var{pps'})}\\
          \end{array}
        \right)
      }\\ ~ \\
      \var{pids_{keep}} = \{ \var{pid} \mid
      \var{pid} \mapsto (\var{pv_i}, \wcard) \in \var{rups}
      ,~ \var{pv'} \leq \var{pv_i}\}
    }
    {
      {
        \begin{array}{l}
          k\\
          u\\
          e_c\\
          b_n\\
          \var{dms}\\
        \end{array}
      }
      \vdash
      {
        \left(
          \begin{array}{l}
            \var{e_p}\\
            \var{(\var{pv}, \var{pps})}\\
            \var{(\var{pv_c}, \var{pps_c})}\\
            \var{rups}\\
            \var{eps}\\
            \var{cps}\\
            \var{vts}\\
            \var{bvs}\\
            \var{pws}
          \end{array}
        \right)
      }
      \trans{upiec}{\var{e_n}}
      {
        \left(
          \begin{array}{l}
            \var{e'}\\
            \var{(\var{pv'}, \var{pps} \unionoverride \var{pps'})}\\
            \var{(\var{pv_c}, \var{pps_c})}\\
            \var{pids_{keep}} \restrictdom \var{rups}\\
            {[e_n, ..]} \restrictdom \var{eps}\\
            \var{pids_{keep}} \restrictdom \var{cps}\\
            \var{pids_{keep}} \restrictdom \var{vts}\\
            {[\var{pv'}, ..]} \restrictdom \var{bvs}\\
            \var{pids_{keep}} \restrictdom \var{pws}
          \end{array}
        \right)
      }
    }
  \end{equation}
  \caption{Block version adoption on epoch change rules}
  \label{fig:rules:upi-ec}
\end{figure}
